{"dependencies":[{"name":"react","loc":{"line":7,"column":33}},{"name":"classnames","loc":{"line":8,"column":23}},{"name":"semantic-ui-react","loc":{"line":21,"column":7}},{"name":"../socketIoHOC","loc":{"line":22,"column":24}},{"name":"../WordList/WordList","loc":{"line":24,"column":21}},{"name":"../Tile/Tile","loc":{"line":25,"column":17}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // todo: REFACTOR THIS TO USE REDUX HOLY HELL\n//  would actually be a perfect thing to make a youtube tutorial about\n//  how using redux could refactor this into smaller components easier\n//  since you wouldn't have to pass setState methods down to components \n//  via props. do that.\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _classnames = require(\"classnames\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _semanticUiReact = require(\"semantic-ui-react\");\n\nvar _socketIoHOC = require(\"../socketIoHOC\");\n\nvar _socketIoHOC2 = _interopRequireDefault(_socketIoHOC);\n\nvar _WordList = require(\"../WordList/WordList\");\n\nvar _WordList2 = _interopRequireDefault(_WordList);\n\nvar _Tile = require(\"../Tile/Tile\");\n\nvar _Tile2 = _interopRequireDefault(_Tile);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst tilesAcross = 15;\nconst tilesDown = 15;\nconst totalTiles = tilesAcross * tilesDown;\n\n// Server expects data in this format\nconst initialTableData = [[null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]];\n\nconst initialState = {\n  coordinatesToHighlight: [],\n  wordChars: '',\n  rack: '',\n  editableTileCoordinates: {\n    x: null,\n    y: null\n  },\n  gameType: 'wwf', // wwf : scrabble\n  moveDirection: null, // will be either 'down' or 'right'\n  tableData: initialTableData,\n  wordHoveredKey: null,\n  loading: false,\n  suggestedWords: null\n\n  // Todo: push some of this logic into this into WordListContainer and TileContainer so this file is less huge\n};class Board extends _react.Component {\n  constructor(props) {\n    super(props);\n\n    _initialiseProps.call(this);\n\n    this.state = _extends({}, initialState);\n\n    this.wrapperRef = null;\n\n    const gameType = localStorage.getItem('gameType');\n    if (gameType) {\n      this.setState({ gameType });\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.loading !== this.props.loading) {\n      this.setState({\n        loading: nextProps.loading\n      });\n    }\n\n    if (this.props.suggestedWords) {\n      this.setState({ suggestedWords: this.props.suggestedWords });\n    }\n  }\n\n  // For clicking outside of tile area\n  componentDidMount() {\n    document.addEventListener('mousedown', this.handleClickOutside);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.handleClickOutside);\n  }\n\n  // handle table data\n\n\n  // Build board logic\n\n\n  render() {\n    return _react2.default.createElement(\n      _semanticUiReact.Container,\n      { className: \"mt-50px\" },\n      _react2.default.createElement(\n        _semanticUiReact.Grid,\n        { className: \"scrabble-container centered\" },\n        _react2.default.createElement(\n          _semanticUiReact.Grid.Column,\n          { className: \"fixed-width-left-col\" },\n          _react2.default.createElement(\n            _semanticUiReact.Header,\n            { as: \"h2\" },\n            \"Words With Fiends\",\n            _react2.default.createElement(\n              _semanticUiReact.Header.Subheader,\n              null,\n              \"Generate answers for Words With Friends or Scrabble\",\n              _react2.default.createElement(_semanticUiReact.Popup, {\n                trigger: _react2.default.createElement(_semanticUiReact.Button, { className: \"info-popover\", icon: \"question\" }),\n                content: \"Enter your rack to the right, add all played letters to the board below, and you're good to go!\"\n              })\n            )\n          ),\n          _react2.default.createElement(\n            \"div\",\n            { ref: ref => {\n                this.wrapperRef = ref;\n              } },\n            _react2.default.createElement(\n              _semanticUiReact.Table,\n              { unstackable: true, celled: true },\n              _react2.default.createElement(\n                _semanticUiReact.Table.Body,\n                null,\n                this.buildBoard()\n              )\n            )\n          ),\n          _react2.default.createElement(\n            \"div\",\n            { className: \"section-toggle-game\" },\n            _react2.default.createElement(\n              _semanticUiReact.Label,\n              null,\n              _react2.default.createElement(\n                \"div\",\n                { className: \"mt-10px\" },\n                _react2.default.createElement(_semanticUiReact.Radio, {\n                  slider: true,\n                  onChange: this.toggleGameType\n                })\n              ),\n              _react2.default.createElement(\n                \"div\",\n                { className: \"mt-10px\" },\n                _react2.default.createElement(\n                  _semanticUiReact.Label.Detail,\n                  null,\n                  this.state.gameType === 'wwf' ? 'Words With Friends' : 'Scrabble'\n                )\n              )\n            )\n          )\n        ),\n        _react2.default.createElement(\n          _semanticUiReact.Grid.Column,\n          { className: \"mt-24px fixed-width-right-col\" },\n          _react2.default.createElement(\n            _semanticUiReact.Label,\n            { className: \"mb-10px\" },\n            _react2.default.createElement(_semanticUiReact.Icon, { name: \"info\" }),\n            \" Enter \",\n            _react2.default.createElement(\n              \"span\",\n              { className: \"big-underscore\" },\n              \"_\"\n            ),\n            \" for blank tiles.\",\n            _react2.default.createElement(\n              \"div\",\n              null,\n              \"Blank tiles on the board will be above a \",\n              _react2.default.createElement(\n                \"span\",\n                { className: \"big-underscore\" },\n                \"_\"\n              ),\n              \".\"\n            )\n          ),\n          _react2.default.createElement(\n            \"form\",\n            { onSubmit: this.handleSendTableData },\n            _react2.default.createElement(\n              _semanticUiReact.Grid,\n              null,\n              _react2.default.createElement(\n                _semanticUiReact.Grid.Column,\n                { width: 8 },\n                _react2.default.createElement(_semanticUiReact.Input, {\n                  placeholder: \"Enter your rack...\",\n                  className: \"rack\",\n                  value: this.state.rack,\n                  onChange: this.handleRackChange\n                })\n              ),\n              _react2.default.createElement(\n                _semanticUiReact.Grid.Column,\n                { width: 8 },\n                _react2.default.createElement(\n                  _semanticUiReact.Button,\n                  {\n                    className: \"btn-get-word\",\n                    type: \"submit\",\n                    disabled: this.props.loading\n                  },\n                  this.props.loading ? _react2.default.createElement(_semanticUiReact.Loader, { size: \"tiny\", active: true, inline: true }) : 'Get Words'\n                )\n              )\n            )\n          ),\n          _react2.default.createElement(_WordList2.default, {\n            words: this.state.suggestedWords,\n            addWordToTable: this.addWordToTable,\n            wordHoveredKey: this.state.wordHoveredKey,\n            handleHighlightWordOnHover: this.handleHighlightWordOnHover\n          })\n        )\n      )\n    );\n  }\n}\n\nvar _initialiseProps = function () {\n  this.handleClickOutside = e => {\n    if (this.wrapperRef && !this.wrapperRef.contains(e.target)) {\n      this.setState({\n        editableTileCoordinates: {\n          x: null,\n          y: null\n        },\n        moveDirection: null\n      });\n    }\n  };\n\n  this.addWordToTable = (wordInfo, wordIndexInSuggestedWords) => {\n    // add to table data and update suggested words\n    const newData = this.state.tableData.slice();\n\n    const firstY = wordInfo[1][0][0];\n    const secondY = wordInfo[1][1][0];\n\n    const firstX = wordInfo[1][0][1];\n    const secondX = wordInfo[1][1][1];\n\n    const yDistance = secondY - firstY;\n    const xDistance = secondX - firstX;\n\n    if (firstY === secondY) {\n\n      for (let i = 0; i <= xDistance; i++) {\n        newData[firstY][firstX + i] = wordInfo[2][i].length === 2 ? wordInfo[2][i].split('')[0] : wordInfo[2][i];\n      }\n    } else if (firstX === secondX) {\n\n      for (let i = 0; i <= yDistance; i++) {\n        newData[firstY + i][firstX] = wordInfo[2][i].length === 2 ? wordInfo[2][i].split('')[0] : wordInfo[2][i];\n      }\n    }\n\n    const newSuggestedWordsList = this.state.suggestedWords.slice();\n    delete newSuggestedWordsList[wordIndexInSuggestedWords];\n\n    // todo: split out into array\n    let currentRack = this.state.rack.split('').slice();\n    let wordPlayed = wordInfo[2].slice();\n\n    // todo: yeesh this is all unreadable, refactor when less rushed\n    for (let i = wordPlayed.length; i--;) {\n      if (wordPlayed[i].length === 2 && wordPlayed[i][1] !== '_') {\n        delete wordPlayed[i]; // delete tiles that are already on board\n      }\n    }\n\n    wordPlayed = wordPlayed.join('').split('').slice(); // get rid of empty cells\n\n    for (let j = wordPlayed.length; j--;) {\n      if (currentRack.includes(wordPlayed[j])) {\n        let indexOfCellToRemove = currentRack.indexOf(wordPlayed[j]);\n\n        delete currentRack[indexOfCellToRemove];\n        delete wordPlayed[j];\n      }\n    }\n\n    currentRack = currentRack.join(''); // get rid of undefined's and turn into string\n    console.log('currentRack', currentRack);\n\n    this.setState({\n      tableData: newData,\n      suggestedWords: newSuggestedWordsList,\n      rack: currentRack\n    }, () => {\n      if (currentRack.length) {\n        this.handleSendTableData();\n      } else {\n        this.setState({ suggestedWords: null });\n      }\n    });\n  };\n\n  this.handleSendTableData = e => {\n    if (e) {\n      e.preventDefault();\n    }\n\n    this.props.toggleLoadingState();\n\n    // should be false for spaces / special chars besides _\n    const tableData = {\n      gameType: this.state.gameType,\n      board: this.state.tableData,\n      rack: this.state.rack\n    };\n\n    this.props.socket.emit('analyze_board', JSON.stringify(tableData));\n  };\n\n  this.handleMakeTileEditable = (tileCoordinates, newClick) => {\n    // If this is being called from <Tile />, its a new click so the user hasn't\n    //   set a direction yet.\n    if (newClick) {\n      this.setState({\n        moveDirection: null,\n        editableTileCoordinates: tileCoordinates\n      });\n    } else {\n      // If this is being called from handleTileValueChanged(), keep going the same direction\n      this.setState({ editableTileCoordinates: tileCoordinates });\n    }\n  };\n\n  this.handleTileValueChanged = (newTileValue, tileCoordinates, moveDirection) => {\n    // Calculate row \n    const row = tileCoordinates.y;\n    const newRowStateRow = this.state.tableData[row];\n    const newState = this.state.tableData;\n    newRowStateRow[tileCoordinates.x] = newTileValue.toUpperCase();\n    newState[row] = newRowStateRow;\n\n    // Allow user to select a move direction before inputs a value\n    if (!newTileValue && moveDirection) {\n      this.setState({ moveDirection }, () => {\n        this.handleMakeTileEditable(tileCoordinates);\n      });\n      return;\n    }\n\n    this.setState({\n      editableTileCoordinates: {\n        x: null,\n        y: null\n      },\n      tableData: newState,\n      wordChars: '',\n      initialRack: '',\n      moveDirection: moveDirection\n    }, () => {\n\n      const newTileCoordinates = Object.assign({}, tileCoordinates);\n      // If horizontal\n      if (this.state.moveDirection === 'right') {\n        if (tileCoordinates.x === 14) {\n          return;\n        } else {\n          newTileCoordinates.x = tileCoordinates.x + 1;\n        }\n      } else if (this.state.moveDirection === 'down') {\n        if (tileCoordinates.y === 14) {\n          return;\n        } else {\n          newTileCoordinates.y = tileCoordinates.y + 1;\n        }\n      }\n\n      this.handleMakeTileEditable(newTileCoordinates);\n    });\n  };\n\n  this.handleHighlightWordOnHover = (coordinatesToHighlight, i) => {\n    this.setState({\n      coordinatesToHighlight: coordinatesToHighlight,\n      wordHoveredKey: i\n    });\n  };\n\n  this.buildBoard = () => {\n    const board = [];\n    // These three vars get altered when endRow is true\n    let row = [];\n    let rowNumber = 0;\n    let cellNumber = 0;\n\n    for (let i = 0; i < totalTiles; i++) {\n      const tileCoordinates = { x: cellNumber, y: rowNumber };\n      const endRow = cellNumber === 14 ? true : false;\n\n      const tileIsEditable = this.state.editableTileCoordinates.x === cellNumber && this.state.editableTileCoordinates.y === rowNumber ? true : false;\n\n      row.push(_react2.default.createElement(_Tile2.default, {\n        key: i,\n        tileIsEditable: tileIsEditable,\n        tileCoordinates: tileCoordinates,\n\n        handleTileValueChanged: this.handleTileValueChanged,\n        handleMakeTileEditable: this.handleMakeTileEditable,\n\n        gameType: this.state.gameType,\n        moveDirection: this.state.moveDirection,\n        coordinatesToHighlight: this.state.coordinatesToHighlight,\n        cellChar: this.state.tableData[rowNumber][cellNumber]\n      }));\n\n      cellNumber++;\n\n      if (endRow) {\n        board.push(_react2.default.createElement(_semanticUiReact.Table.Row, {\n          key: rowNumber,\n          children: row\n        }));\n\n        // reset row after its pushed / increment rowNumber to next row / and reset cell we are at\n        row = [];\n        rowNumber = rowNumber + 1;\n        cellNumber = 0;\n      }\n    }\n\n    return board;\n  };\n\n  this.handleRackChange = (e, data) => {\n    const rack = data.value || '';\n\n    if (data.value.length === 0) {\n      // user highlighted and cleared input\n      this.setState({\n        rack: ''\n      });\n    }\n\n    if (/^[A-Za-z_]+$/.test(rack) && rack.length <= 7) {\n      // Don't allow weird chars\n      this.setState({\n        rack: data.value.toUpperCase()\n      });\n    }\n  };\n\n  this.toggleGameType = () => {\n    const gameType = this.state.gameType === 'wwf' ? 'scrabble' : 'wwf';\n    this.setState({ gameType });\n  };\n};\n\nexports.default = (0, _socketIoHOC2.default)(Board);"},"hash":"eebca7596559acf72c227c4e6965e1f8"}