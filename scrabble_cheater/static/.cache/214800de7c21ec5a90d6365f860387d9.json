{"dependencies":[{"name":"react","loc":{"line":1,"column":33}},{"name":"semantic-ui-react","loc":{"line":2,"column":43}},{"name":"classnames","loc":{"line":3,"column":23}},{"name":"../../constants","loc":{"line":5,"column":24}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _semanticUiReact = require(\"semantic-ui-react\");\n\nvar _classnames = require(\"classnames\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _constants = require(\"../../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Tile extends _react.Component {\n  constructor(props) {\n    super(props);\n\n    _initialiseProps.call(this);\n\n    this.state = {\n      newTileValue: '',\n      direction: null\n    };\n  }\n\n  componentDidUpdate() {\n    if (this.inputRef) {\n      this.inputRef.focus();\n    }\n  }\n\n  shouldComponentUpdate(nextProps) {\n    if (this.props.gameType !== nextProps.gameType) {\n      return true;\n    }\n\n    // Update if this Tile is marked as editable or remove from being editable\n    if (nextProps.tileIsEditable || nextProps.tileIsEditable !== this.props.tileIsEditable) {\n      return true;\n    }\n\n    // This seems super expensive to have in shouldComponentUpdate\n    const oldTile = this.shouldCellUpdate(this.props);\n    const newTile = this.shouldCellUpdate(nextProps);\n\n    if (oldTile || newTile) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  componentWillReceiveProps(nextProps, nextState) {\n    if (nextProps.cellChar && !this.state.newTileValue) {\n      // So when a user is adding new letters to the board, \n      // if a one is added via menu, it stays when they are auto placed into it\n      this.setState({\n        newTileValue: nextProps.cellChar\n      });\n    }\n  }\n\n  render() {\n    let char = this.props.cellChar || '';\n    let highlightCell = false;\n    let onBoard = false;\n    let blankTile = false;\n    let playedTile = this.props.cellChar ? true : false;\n\n    console.log('blankTile,', blankTile);\n\n    const tw = this.testForBonusTile(_constants.scores[this.props.gameType].trippleWordScore);\n    const dw = this.testForBonusTile(_constants.scores[this.props.gameType].doubleWordScore);\n    const tl = this.testForBonusTile(_constants.scores[this.props.gameType].trippleLetterScore);\n    const dl = this.testForBonusTile(_constants.scores[this.props.gameType].doubleLetterScore);\n\n    this.props.coordinatesToHighlight.filter(coordinates => {\n      if (coordinates.x === this.props.tileCoordinates.x && coordinates.y === this.props.tileCoordinates.y) {\n        if (coordinates.char.length == 2) {\n\n          let charInfo = coordinates.char.split('');\n          char = charInfo[0];\n\n          if (charInfo[1] === '#') {\n\n            onBoard = true;\n          } else if (charInfo[1] === '_') {\n\n            blankTile = true;\n          }\n        } else {\n          char = coordinates.char;\n        }\n        highlightCell = true;\n      }\n    });\n\n    if (this.props.tileIsEditable) {\n      return _react2.default.createElement(\n        _semanticUiReact.Table.Cell,\n        null,\n        _react2.default.createElement(\n          \"form\",\n          { className: \"ui form\", onSubmit: this.handleSubmitTile },\n          _react2.default.createElement(_semanticUiReact.Input, {\n            onKeyDown: this.handleArrowPress,\n            value: this.state.newTileValue,\n            onChange: this.updateStateWithTileValue,\n            ref: ref => {\n              this.inputRef = ref;\n            },\n            onFocus: this.handleFocus\n          }),\n          this.props.moveDirection ? // todo: move this to function its huge\n          // TODO: figure out how to get patthern=\"XX\" to trigger from right / down arrorws\n          _react2.default.createElement(\n            _semanticUiReact.Button,\n            {\n              type: \"button\",\n              className: (0, _classnames2.default)(\"btn-tile-submit\", this.props.moveDirection === 'down' ? 'move-down' : null),\n              onClick: this.handleSubmitTile\n            },\n            _react2.default.createElement(\"i\", { className: \"fas fa-plus\" })\n          ) : _react2.default.createElement(\n            \"span\",\n            null,\n            _react2.default.createElement(\n              _semanticUiReact.Button,\n              {\n                type: \"button\",\n                className: \"btn-tile-submit right-arrow\",\n                onClick: this.handleMoveRight\n              },\n              _react2.default.createElement(\"i\", { className: \"fas fa-arrow-right\" })\n            ),\n            _react2.default.createElement(\n              _semanticUiReact.Button,\n              {\n                type: \"button\",\n                className: \"btn-tile-submit down-arrow\",\n                onClick: this.handleMoveDown\n              },\n              _react2.default.createElement(\"i\", { className: \"fas fa-arrow-down\" })\n            )\n          )\n        )\n      );\n    } else {\n      return _react2.default.createElement(\n        _semanticUiReact.Table.Cell,\n        {\n          selectable: true,\n          textAlign: \"center\",\n          className: (0, _classnames2.default)('tile-bg-color', {\n            'tw': tw,\n            'dw': dw,\n            'tl': tl,\n            'dl': dl,\n            'played-tile': playedTile,\n            'highlight-word-location': highlightCell,\n            'on-board': onBoard\n          }),\n          onClick: this.handleClick\n        },\n        _react2.default.createElement(\n          \"span\",\n          null,\n          _react2.default.createElement(\n            \"div\",\n            { className: (0, _classnames2.default)({ 'blank-tile': blankTile }) },\n            char\n          )\n        )\n      );\n    }\n  }\n}\n\nvar _initialiseProps = function () {\n  this.shouldCellUpdate = props => {\n    // This is super expensive. Need to make this way better. \n    // Maybe go back to using the cell# instead of x/y coords for faster lookup\n\n\n    // TODO: Hold a flat version of this or something in props an do a compare against that so you dont have to \n    //   use forEach on every hover :: this is stupid expensive\n    let update = false;\n    props.coordinatesToHighlight.forEach(coordinate => {\n      if (coordinate.x === this.props.tileCoordinates.x && coordinate.y === this.props.tileCoordinates.y) {\n        update = true;\n      }\n    });\n\n    return update;\n  };\n\n  this.handleClick = e => {\n    e.preventDefault();\n    const newClick = true;\n    this.props.handleMakeTileEditable(this.props.tileCoordinates, newClick);\n  };\n\n  this.updateStateWithTileValue = (event, data) => {\n    const { value } = data;\n\n    if (value.length == 0) {\n      this.setState({ newTileValue: '' });\n    } else if (value.length > 1) {\n      return;\n    }\n\n    if (/^[A-Za-z_]+$/.test(value)) {\n      this.setState({ newTileValue: value.toUpperCase() }, () => {\n        if (this.state.direction || this.props.moveDirection) {\n          this.handleSubmitTile();\n        }\n      });\n    } else {\n      return;\n    }\n  };\n\n  this.handleFocus = e => {\n    e.target.select();\n  };\n\n  this.handleSubmitTile = e => {\n    if (e) {\n      // incase user hits enter without choosting a direction\n      e.preventDefault();\n    }\n    const direction = this.props.moveDirection ? this.props.moveDirection : this.state.direction;\n    this.props.handleTileValueChanged(this.state.newTileValue, this.props.tileCoordinates, direction);\n  };\n\n  this.handleMoveRight = () => {\n    this.setState({ direction: 'right' }, () => this.handleSubmitTile());\n  };\n\n  this.handleMoveDown = () => {\n    this.setState({ direction: 'down' }, () => this.handleSubmitTile());\n  };\n\n  this.handleArrowPress = e => {\n    if (e.key === 'ArrowDown') {\n      this.handleMoveDown();\n    } else if (e.key === 'ArrowRight') {\n      this.handleMoveRight();\n    }\n\n    if (!this.state.direction && e.key === 'Enter') {\n      // submit is picked up by form's onSubmit so don't need to handle submit tile also\n      this.setState({ direction: 'right' });\n    }\n  };\n\n  this.testForBonusTile = bonusScoreArray => {\n    return bonusScoreArray.some(elem => {\n      return elem[0] === this.props.tileCoordinates.y && elem[1] === this.props.tileCoordinates.x;\n    });\n    return false;\n  };\n};\n\nexports.default = Tile;"},"hash":"b27b7a44dcc61e5f9ef9fc672aad0e5f"}